commonfields:
  id: VirusTotal - Private API
  version: -1
name: VirusTotal - New
display: VirusTotal - New
category: Data Enrichment & Threat Intelligence
image: data:image/png;base64,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
description: Analyze suspicious hashes, URLs, domains and IP addresses
detaileddescription: |-
  Indicators thresholds:
  Configure the default threshold for each indicator type in the instance settings.
  Note that it is also possible to specify the threshold when runing the command.
  Indicators with positive results equal or bigger than the threshold will be considered malicious.
  Indicators with positive results equal or bigger than half of the threshold value, and lower than the threshold, will be considered suspicious.
configuration:
- display: Virus Total private API key
  name: APIKey
  defaultvalue: ""
  type: 4
  required: true
- display: Use system proxy settings
  name: useProxy
  defaultvalue: "true"
  type: 8
  required: false
- display: Trust any certificate (unsecure)
  name: insecure
  defaultvalue: "false"
  type: 8
  required: false
- display: File Threshold. Minimum number of positive results from VT scanners to
    consider the file malicious.
  name: fileThreshold
  defaultvalue: "10"
  type: 0
  required: false
- display: IP Threshold. Minimum number of positive results from VT scanners to consider
    the IP malicious.
  name: ipThreshold
  defaultvalue: "10"
  type: 0
  required: false
- display: URL Threshold. Minimum number of positive results from VT scanners to consider
    the URL malicious.
  name: urlThreshold
  defaultvalue: "10"
  type: 0
  required: false
- display: Domain Threshold. Minimum number of positive results from VT scanners to
    consider the domain malicious.
  name: domainThreshold
  defaultvalue: "10"
  type: 0
  required: false
script:
  script: |
    ''' IMPORTS '''
    import requests
    import json
    import os
    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBAL VARS '''
    SERVER_URL='https://www.virustotal.com/vtapi/v2/'
    API_KEY=demisto.params()['APIKey']

    USE_SSL = True if demisto.params().get('insecure') else False

    DEFAULT_HEADERS = {
      "Accept-Encoding": "gzip, deflate",
      "User-Agent" : "gzip,  My Python requests library example client or username"
    }

    ''' HELPER FUNCTIONS '''

    def load_proxy():
        """ Loads the system configured proxy if enabled in configuration """
        proxy = {}
        if "proxy" in demisto.params():
            proxy["http"] = os.environ["http_proxy"]
            proxy["https"] = os.environ["https_proxy"]
        return proxy

    PROXY = load_proxy()

    def http_request(method, url_suffix, params_dict, headers):
        req_params = {
            'apikey': API_KEY
        }
        if params_dict is not None:
            req_params.update(params_dict)

        url = SERVER_URL + url_suffix
        LOG('running %s request with url=%s\theaders=%s\nparams=%s' % (method, url, headers, json.dumps(req_params)))

        try:
            res = requests.request(method,
                url,
                verify=USE_SSL,
                params=req_params,
                headers=headers,
                proxies=PROXY
            )
            res.raise_for_status()
            return res.json()

        except Exception, e:
            LOG(e)
            raise(e)

    def create_scans_table(scans):
        """
        Returns a table with the scan result for each vendor
        """

        scans_table = []
        for scan in scans:
            dict_for_table = {
                "Source": scan,
                "Detected": scans.get(scan).get('detected', None),
                "Result": scans.get(scan).get('result', None),
                "Details": scans.get(scan).get('detail', None)
            }
            scans_table.append(dict_for_table)

        return tableToMarkdown('Scans', scans_table)

    def create_file_output(file_hash, threshold, vt_response, long_format):
        ec = {}
        md = ''

        positives = demisto.get(vt_response, 'positives')
        ec['DBotScore'] = []

        md += '## VirusTotal Hash Reputation for: ' + str(vt_response.get('resource')) + '\n'
        md += 'Scan ID: **' + str(vt_response.get('scan_id')) + '**\n'
        md += 'Scan date: **' + str(vt_response.get('scan_date')) + '**\n'
        md += 'Positives / Total: **' + str(positives) + '/' + str(vt_response.get('total')) + '**\n'
        md += 'VT Link: [' + str(vt_response.get('resource')) + '](' + str(vt_response.get('permalink')) + ')\n'
        dbotScore = 0;

        if (positives >= threshold):
            ec.update({
                'File': {
                    'MD5': vt_response.get('md5'),
                    'SHA1': vt_response.get('sha1'),
                    'SHA256': vt_response.get('sha256'),
                    'Malicious': {
                        'Vendor': 'VirusTotal',
                        'Detections': positives,
                        'TotalEngines': demisto.get(vt_response, 'total')
                    },
                },
                'DBotScore': [
                    {
                        'Indicator': file_hash,
                        'Type': 'hash',
                        'Vendor': 'VirusTotal',
                        'Score': 3
                    }
                ]
            })
        elif (positives >= threshold / 2):
            dbotScore = 2
        else:
            dbotScore = 1

        ec['DBotScore'].append({'Indicator': file_hash, 'Type': 'hash', 'Vendor': 'VirusTotal', 'Score': dbotScore})
        md += 'MD5: **' + vt_response.get('md5') + '**\n'
        md += 'SHA1: **' + vt_response.get('sha1') + '**\n'
        md += 'SHA256: **' + vt_response.get('sha256') + '**\n'

        if (long_format and vt_response.get('scans', False)):
            scans = vt_response.pop('scans')
            scans_table = create_scans_table(scans)
            md += scans_table
            md += '\n'

        entry = {
            'Type': entryTypes['note'],
            'Contents': vt_response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': ec
        }
        return entry

    def remove_duplicates_from_list_of_dicts(designated_dict):
        return [dict(t) for t in set([tuple(d.items()) for d in designated_dict])]

    ''' COMMANDS FUNCTIONS '''

    def check_file_behaviour(file_hash):
        """
        Returns the file execution report.
        """

        params = {
            'hash': file_hash
        }

        api_endpoint = 'file/behaviour'
        return http_request('GET', api_endpoint, params, DEFAULT_HEADERS)


    def check_file_behaviour_command():
        """
        corresponds to 'vt-check-file-behaviour' command. Retrieves a report about the execution of a file
        """
        # variables
        args = demisto.args()
        file_hash = args.get('resource')
        threshold = int(args.get('threshold', None) or demisto.params().get('fileThreshold', None) or 10);
        md = ''
        # VT response
        response = check_file_behaviour(file_hash)

        if (response.get('response_code', None) == 0):
            return {
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'EntryContext': {"DBotScore" : {'Indicator': file_hash, 'Type': 'hash', 'Vendor': 'VirusTotal', 'Score': 0}},
                'HumanReadable': "A report wasn't found for file " + file_hash + ". Virus Total returned the following response: " + json.dumps(response.get('verbose_msg'))
            }

        # data processing

        # network data contains all the communication data
        network_data = response.get('network', None)

        hosts = network_data.get('hosts', None)
        if (hosts is not None):
            md += tableToMarkdown('Hosts that hash: ' + file_hash + ' communicates with are:', remove_duplicates_from_list_of_dicts([{'Host':host} for host in hosts]))

        ips_list = []
        domains_list = []
        urls_list = []

        udp_communication = network_data.get('udp', None)
        if (udp_communication is not None):
            for entry in udp_communication:
                ips_list.append(entry.get('dst', None))

        http_communication = network_data.get('http', None)
        if (http_communication is not None):
            for entry in http_communication:
                urls_list.append(entry.get('uri', None))
                domains_list.append(entry.get('host', None))

        tcp_communication = network_data.get('tcp', None)
        if (tcp_communication is not None):
            for entry in tcp_communication:
                ips_list.append(entry.get('dst', None))

        dns_communication = network_data.get('dns', None)
        if (dns_communication is not None):
            for entry in dns_communication:
                ips_list.append(entry.get('ip', None))
                domains_list.append(entry.get('hostname', None))

        if (len(ips_list) > 0):
            md += tableToMarkdown('IPs that hash: ' + file_hash + ' communicates with are:', remove_duplicates_from_list_of_dicts([{'IP':ip} for ip in ips_list]))

        if (len(domains_list) > 0):
            md += tableToMarkdown('Domains that hash: ' + file_hash + ' communicates with are:', remove_duplicates_from_list_of_dicts([{'Domain':domain} for domain in domains_list]))

        if (len(urls_list) > 0):
            md += tableToMarkdown('URLs that hash: ' + file_hash + ' communicates with are:',  remove_duplicates_from_list_of_dicts([{'URL':url} for url in urls_list]))

        files_data, keys_data, mutex_data = None, None, None

        behavior_data = response.get('behavior', None)
        if behavior_data is not None:
            summary_data = behavior_data.get('summary', None)
            if summary_data is not None:
                files_data = summary_data.get('files', None)
                keys_data = summary_data.get('keys', None)
                mutex_data = summary_data.get('mutexes', None)

        if (files_data is not None):
            md += tableToMarkdown('Files that are related to hash: ' + file_hash + ' :', remove_duplicates_from_list_of_dicts([{'File':file} for file in files_data]))

        if (keys_data is not None):
            md += tableToMarkdown('Keys that are related to hash: ' + file_hash + ' :', remove_duplicates_from_list_of_dicts([{'Key':k} for k in keys_data]))

        if (mutex_data is not None):
            md += tableToMarkdown('Opened mutexes that are related to hash: ' + file_hash + ' :',  remove_duplicates_from_list_of_dicts([{'Mutex':m} for m in mutex_data]))

        return {
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'VirusTotal.FileBehaviour.Domain(val==obj)': domains_list,
                'VirusTotal.FileBehaviour.URL(val==obj)': urls_list,
                'VirusTotal.FileBehaviour.IP(val==obj)': ips_list,
                'VirusTotal.FileBehaviour.Host(val==obj)': hosts,
                'VirusTotal.FileBehaviour.File(val==obj)': files_data,
                'VirusTotal.FileBehaviour.Key(val==obj)': keys_data,
                'VirusTotal.FileBehaviour.Mutex(val==obj)': mutex_data,

            }
        }

    def get_domain_report(domain):
        """
        Returns the domain report.
        """

        params = {
            'domain': domain
        }

        api_endpoint = 'domain/report'
        return http_request('GET', api_endpoint, params, DEFAULT_HEADERS)


    def get_domain_report_command():
        """
        corresponds to 'vt-get-domain-report' command. Retrieves a report about a domain
        """

        # variables
        args = demisto.args()
        domain = args['domain']
        threshold = int(args.get('threshold', None) or demisto.params().get('domainThreshold', None) or 10);
        md = ''

        # VT Response
        response = get_domain_report(domain)

        if (response.get('response_code') == -1):
            return "Invalid domain"
        elif (response.get('response_code') == 0):
            return {
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'EntryContext': {"DBotScore" : {'Indicator': domain, 'Type': 'domain', 'Vendor': 'VirusTotal', 'Score': 0}},
                'HumanReadable': "Domain " + domain + "not in Virus Total's dataset. Virus Total returned the following response: " + json.dumps(response.get('verbose_msg'))
            }

        # data processing
        del response['response_code']

        communicating_hashes = response.get('detected_communicating_samples', None)

        communicating_malware_hashes = []
        if communicating_hashes:
            for d_hash in communicating_hashes:
                positives = d_hash.get('positives')
                if (positives >= threshold):
                    communicating_malware_hashes.append(d_hash)
            md += tableToMarkdown("Latest detected files that communicated with " + domain, communicating_malware_hashes)

        downloaded_hashes = response.get('detected_downloaded_samples', None)

        downloaded_malware_hashes = []
        if downloaded_hashes:
            for d_hash in downloaded_hashes:
                positives = d_hash.get('positives')
                if (positives >= threshold):
                    downloaded_malware_hashes.append(d_hash)
            md += tableToMarkdown("Latest detected files that were downloaded from " + domain, downloaded_malware_hashes)

        resolutions = response.get('resolutions', None)

        resolutions_list = []
        if resolutions:
            for res in resolutions:
                resolutions_list.append(res)
            md += tableToMarkdown(domain + " has been resolved to the following IP addresses:", resolutions_list)

        whois = response.get('whois', None)
        if whois is not None:
            md += "## Whois analysis: \n"
            md += whois + '\n'

        subdomains = response.get('subdomains', None)
        if whois is not None:
            md += tableToMarkdown("Observed subdomains", [{'Domain':d} for d in subdomains])

        return {
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'VirusTotal.domainReport.DownloadedHashes(val.sha256==obj.sha256)': downloaded_malware_hashes,
                'VirusTotal.domainReport.CommunicatingHashes(val.sha256==obj.sha256)': communicating_malware_hashes,
                'VirusTotal.domainReport.Reolutions(val.ip_address==obj.ip_address)': resolutions_list,
                'VirusTotal.domainReport.Whois(val==obj)': whois,
                'VirusTotal.domainReport.Subdomains(val==obj)': subdomains
            }
        }

    def get_file_report(file_hash, all_info):
        """
        Returns the file execution report.
        """

        params = {
            'resource': file_hash,
            'allinfo': all_info
        }

        api_endpoint = 'file/report'
        return http_request('GET', api_endpoint, params, DEFAULT_HEADERS)


    def get_file_report_command():
        """
        corresponds to 'vt-get-file-report' command. Retrieves a report about the execution of a file
        """

        args = demisto.args()
        file_hash = args.get('resource')
        long_format = args.get('longFormat', None) == 'true'
        all_info = args.get('allInfo', None)
        all_info = 1 if all_info == 'true' else 0
        threshold = int(args.get('threshold', None) or demisto.params().get('fileThreshold', None) or 10);

        response = get_file_report(file_hash, all_info)

        if (response.get('response_code', None) == 0):
            return "A report wasn't found. Virus Total returned the following response: " + json.dumps(response.get('verbose_msg'))

        del response['response_code']

        output = create_file_output(file_hash, threshold, response, long_format)

        return output

    def get_url_report(url, all_info):
        """
        Returns a report about an url.
        """

        params = {
            'resource': url,
            'allinfo': all_info,
            'scan': 1
        }

        api_endpoint = 'url/report'
        return http_request('GET', api_endpoint, params, DEFAULT_HEADERS)


    def get_url_report_command():
        """
        corresponds to 'vt-get-url-report' command. Retrieves a report about a url
        """

        args = demisto.args()
        url = args.get('resource')
        all_info = 1 if args.get('allInfo', None) == 'true' else 0
        threshold = int(args.get('threshold', None) or demisto.params().get('urlThreshold', None) or 10);
        long_format = args.get('longFormat', None)
        response = get_url_report(url, all_info)

        if (response.get('response_code', None) == -1):
            return "Invalid url"

        positives = demisto.get(response, 'positives')

        md = '## VirusTotal URL report for: ' + url + '\n'
        md += 'Scan ID: **' + str(response.get('scan_id', '')) + '**\n'
        md += 'Scan date: **' + str(response.get('scan_date', '')) + '**\n'
        md += 'Positives / Total: **' + str(positives) + '/' + str(response.get('total', '')) + '**\n'
        md += 'VT Link: [' + str(response.get('resource', '')) + '](' + str(response.get('permalink', '')) + ')\n'

        ec = {}
        ec['DBotScore'] = []
        dbotScore = 0

        if (positives >= threshold):
            ec.update({
                'URL': {
                    'Data': url,
                    'Malicious': {
                        'Description': 'Positives / Total: ' + positives + ' / ' + response.get('total', ''),
                        'Vendor': 'VirusTotal'
                    },
                },
                'DBotScore': [
                    {
                        'Indicator': url,
                        'Type': 'url',
                        'Vendor': 'VirusTotal',
                        'Score': 3
                    }
                ]
            })
        elif (positives >= threshold / 2):
            dbotScore = 2
        else:
            dbotScore = 1

        ec['DBotScore'].append({'Indicator': url, 'Type': 'url', 'Vendor': 'VirusTotal', 'Score': dbotScore})

        additional_info = response.get('additional_info', None)
        if additional_info is not None:
            resolution = additional_info.get('resolution', None)
            if resolution is not None:
                md += 'IP address resolution for this domain is: ' + resolution + '\n'

        del response['response_code']
        scans = response.get('scans', None)

        if scans is not None and long_format is not None:
            scans_table = create_scans_table(scans)
            md += scans_table

        return {
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': ec
        }

    def get_ip_report(ip):
        """
        Returns an ip report.
        """

        params = {
            'ip': ip
        }

        api_endpoint = 'ip-address/report'
        return http_request('GET', api_endpoint, params, DEFAULT_HEADERS)


    def get_ip_report_command():
        """
        corresponds to 'vt-get-ip-report' command. Retrieves a report about an ip
        """

        args = demisto.args()
        ip = args['ip']
        threshold = int(args.get('threshold', None) or demisto.params().get('ipThreshold', None) or 10);

        response = get_ip_report(ip)

        if (response.get('response_code') == -1):
            return "Invalid IP address "
        elif (response.get('response_code') == 0):
            return {
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'EntryContext': {"DBotScore" : {'Indicator': ip, 'Type': 'ip', 'Vendor': 'VirusTotal', 'Score': 0}},
                'HumanReadable': "IP " + ip + "not in Virus Total's dataset. Virus Total returned the following response: " + json.dumps(response.get('verbose_msg'))
            }
        del response['response_code']

        md = '## VirusTotal IP report for: ' + ip + '\n'
        asn = str(response.get('asn', None)) if response.get('asn', None) else None
        if asn is not None:
            md += 'ASN: **' + asn + ' (' + str(response.get('as_owner', '')) + ')**\n'
        md += 'Country: **' + response.get('country','') + '**\n'

        resolutions = response.get('resolutions', None)

        if resolutions:
            md += tableToMarkdown("The following domains resolved to the given IP address:", resolutions[:50])

        detected_urls = response.get('detected_urls', None)

        if detected_urls:
            md += tableToMarkdown("Latest URLs hosted in this IP address detected by at least one URL scanner or malicious URL dataset:", detected_urls[:50])

        detected_downloaded_samples = response.get('detected_downloaded_samples', None)

        if detected_downloaded_samples:
            md += tableToMarkdown("Latest files that are detected by at least one antivirus solution and were downloaded by VirusTotal from the IP address provided", detected_downloaded_samples[:50])

        undetected_downloaded_samples = response.get('undetected_downloaded_samples', None)

        if undetected_downloaded_samples:
            md += tableToMarkdown("Latest files that are not detected by any antivirus solution and were downloaded by VirusTotal from the IP address provided", undetected_downloaded_samples[:50])

        detected_communicating_samples = response.get('detected_communicating_samples', None)

        if detected_communicating_samples:
            md += tableToMarkdown("Latest detected files that communicate with this IP address", detected_communicating_samples[:50])

        undetected_communicating_samples = response.get('undetected_communicating_samples', None)

        if undetected_communicating_samples:
            md += tableToMarkdown("Latest undetected files that communicate with this IP address", undetected_communicating_samples[:50])

        detected_referrer_samples = response.get('detected_referrer_samples', None)

        if detected_referrer_samples:
            md += tableToMarkdown("Latest detected files that embed this IP address in their strings", detected_referrer_samples[:50])

        undetected_referrer_samples = response.get('undetected_referrer_samples', None)

        if undetected_referrer_samples:
            md += tableToMarkdown("Latest undetected files that embed this IP address in their strings", undetected_referrer_samples[:50])

        ec = {}
        ec['DBotScore'] = []
        dbotScore = 0
        bad_downloads_amount = len(undetected_downloaded_samples)
        if (bad_downloads_amount >= threshold):
            ec.update({
                'ip': {
                    'Address': ip,
                    'ASN': asn,
                    'Geo': {
                        'Country': response.get('country','')
                    },
                    'Malicious': {
                        'Description': 'Recent malicious downloads: ' + str(bad_downloads_amount),
                        'Vendor': 'VirusTotal'
                    },
                },
                'DBotScore': [
                    {
                        'Indicator': ip,
                        'Type': 'ip',
                        'Vendor': 'VirusTotal',
                        'Score': 3
                    }
                ]
            })
        elif (bad_downloads_amount >= threshold / 2):
            dbotScore = 2
        else:
            dbotScore = 1

        ec['DBotScore'] = {'Indicator': ip, 'Type': 'ip', 'Vendor': 'VirusTotal', 'Score': dbotScore}

        return {
            'Type': entryTypes['note'],
            'Contents': response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': ec
        }

    def search_file(query):
        """
        Returns the hashes of files that fits the query.
        """

        params = {
            'query': query
        }

        api_endpoint = 'file/search'
        return http_request('POST', api_endpoint, params, DEFAULT_HEADERS)


    def search_file_command():
        """
        corresponds to 'vt-search-file' command. Returns the hashes of files that fits the query
        """

        args = demisto.args()
        query = args['query']

        response = search_file(query)

        if (response.get('response_code') == -1):
            return "There was some sort of error with your query. Virus Total returned the following response: " + json.dumps(response.get('verbose_msg'))
        elif (response.get('response_code') == 0):
            return "No files matched your query"

        del response['response_code']
        hashes = response.get('hashes',None)

        md = '## Found the following hashes for the query :' + query + '\n'
        md += tableToMarkdown('Hashes are: ', [{'Hash':h} for h in hashes])

        return {
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'ReadableContentsFormat': formats['markdown'],
                'HumanReadable': md,
                'EntryContext': {
                      'VirusTotal.FileSearchHashes(val==obj)': hashes
                }
        }

    def ip_to_communicating_hash_command():
        args = demisto.args()
        ip = args['ip']
        threshold = int(args.get('threshold', None) or demisto.params().get('ipThreshold', None) or 10);

        response = get_ip_report(ip)

        if (response.get('response_code') == -1):
            return "Invalid IP"
        elif (response.get('response_code') == 0):
            return {
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'HumanReadable': "IP " + ip + "not in Virus Total's dataset. Virus Total returned the following response: " + json.dumps(response.get('verbose_msg'))
            }

        communicating_hashes = response.get('detected_communicating_samples', None)

        if not communicating_hashes:
            return "Virus Total didn't any relevant file hashes"

        malware_hashes = []

        for d_hash in communicating_hashes:
            positives = d_hash.get('positives')
            if (positives >= threshold):
                malware_hashes.append(d_hash)

        return {
            'Type': entryTypes['note'],
            'Contents': malware_hashes,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Communicating files hashes for ip: " + ip, malware_hashes),
            'EntryContext': {
                  'VirusTotal.ipToCommunicatingHash(val.sha256==obj.sha256)': malware_hashes
            }
        }

    def ip_to_downloaded_hash_command():
        args = demisto.args()
        ip = args['ip']
        threshold = int(args.get('threshold', None) or demisto.params().get('ipThreshold', None) or 10);

        response = get_ip_report(ip)

        if (response.get('response_code') == -1):
            return "Invalid IP"
        elif (response.get('response_code') == 0):
            return {
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'HumanReadable': "IP " + ip + "not in Virus Total's dataset. Virus Total returned the following response: " + json.dumps(response.get('verbose_msg'))
            }

        downloaded_hashes = response.get('detected_downloaded_samples', None)

        if not downloaded_hashes:
            return "Virus Total didn't any relevant file hashes"

        malware_hashes = []

        for d_hash in downloaded_hashes:
            positives = d_hash.get('positives')
            if (positives >= threshold):
                malware_hashes.append(d_hash)

        return {
            'Type': entryTypes['note'],
            'Contents': malware_hashes,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Downloaded files hashes for ip: " + ip, malware_hashes),
            'EntryContext': {
                  'VirusTotal.ipToDownloadedHash(val.sha256==obj.sha256)': malware_hashes
            }
        }

    def ip_to_domain_command():
        args = demisto.args()
        ip = args['ip']

        response = get_ip_report(ip)

        if (response.get('response_code') == -1):
            return "Invalid IP"
        elif (response.get('response_code') == 0):
            return {
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'HumanReadable': "IP " + ip + "not in Virus Total's dataset. Virus Total returned the following response: " + json.dumps(response.get('verbose_msg'))
            }

        resolutions = response.get('resolutions', None)

        if not resolutions:
            return "Virus Total didn't any relevant domains"

        return {
            'Type': entryTypes['note'],
            'Contents': resolutions,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Resolved domains for ip: " + ip, resolutions),
            'EntryContext': {
                  'VirusTotal.ipToDomain(val.hostname==obj.hostname)': resolutions
            }
        }

    def domain_to_downloaded_hash_command():
        args = demisto.args()
        domain = args['domain']
        threshold = int(args.get('threshold', None) or demisto.params().get('ipThreshold', None) or 10);

        response = get_domain_report(domain)

        if (response.get('response_code') == -1):
            return "Invalid domain"
        elif (response.get('response_code') == 0):
            return {
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'HumanReadable': "Domain " + domain + "not in Virus Total's dataset. Virus Total returned the following response: " + json.dumps(response.get('verbose_msg'))
            }

        downloaded_hashes = response.get('detected_downloaded_samples', None)

        if not downloaded_hashes:
            return "Virus Total didn't any relevant file hashes"

        malware_hashes = []

        for d_hash in downloaded_hashes:
            positives = d_hash.get('positives')
            if (positives >= threshold):
                malware_hashes.append(d_hash)

        return {
            'Type': entryTypes['note'],
            'Contents': malware_hashes,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Downloaded files hashes for domain: " + domain, malware_hashes),
            'EntryContext': {
                  'VirusTotal.domainToDownloadedHash(val.sha256==obj.sha256)': malware_hashes
            }
        }

    def domain_to_communicating_hash_command():
        args = demisto.args()
        domain = args['domain']
        threshold = int(args.get('threshold', None) or demisto.params().get('ipThreshold', None) or 10);

        response = get_domain_report(domain)

        if (response.get('response_code') == -1):
            return "Invalid domain"
        elif (response.get('response_code') == 0):
            return {
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'HumanReadable': "Domain " + domain + "not in Virus Total's dataset. Virus Total returned the following response: " + json.dumps(response.get('verbose_msg'))
            }

        communicating_hashes = response.get('detected_communicating_samples', None)

        if not communicating_hashes:
            return "Virus Total didn't any relevant file hashes"

        malware_hashes = []

        for d_hash in communicating_hashes:
            positives = d_hash.get('positives')
            if (positives >= threshold):
                malware_hashes.append(d_hash)

        return {
            'Type': entryTypes['note'],
            'Contents': malware_hashes,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Communicating files hashes for domain: " + domain, malware_hashes),
            'EntryContext': {
                  'VirusTotal.domainToCommunicatingHash(val.sha256==obj.sha256)': malware_hashes
            }
        }

    def hash_communication_command():
        # variables
        args = demisto.args()
        file_hash = args.get('hash')
        md = ''
        # VT response
        response = check_file_behaviour(file_hash)

        if (response.get('response_code') == 0):
            return {
                'Type': entryTypes['note'],
                'Contents': response,
                'ContentsFormat': formats['json'],
                'EntryContext': {"DBotScore" : {'Indicator': file_hash, 'Type': 'hash', 'Vendor': 'VirusTotal', 'Score': 0}},
                'HumanReadable': "A report wasn't found for file " + file_hash + ". Virus Total returned the following response: " + json.dumps(response.get('verbose_msg'))
            }

        # network data contains all the communication data
        network_data = response.get('network', None)

        hosts = network_data.get('hosts', None)
        if (hosts is not None):
            md += tableToMarkdown('Hosts that hash: ' + file_hash + ' communicates with are:', remove_duplicates_from_list_of_dicts([{'Host':host} for host in hosts]))

        ips_list = []
        domains_list = []
        urls_list = []

        udp_communication = network_data.get('udp', None)
        if (udp_communication is not None):
            for entry in udp_communication:
                ips_list.append(entry.get('dst', None))

        http_communication = network_data.get('http', None)
        if (http_communication is not None):
            for entry in http_communication:
                urls_list.append(entry.get('uri', None))
                domains_list.append(entry.get('host', None))

        tcp_communication = network_data.get('tcp', None)
        if (tcp_communication is not None):
            for entry in tcp_communication:
                ips_list.append(entry.get('dst', None))

        dns_communication = network_data.get('dns', None)
        if (dns_communication is not None):
            for entry in dns_communication:
                ips_list.append(entry.get('ip', None))
                domains_list.append(entry.get('hostname', None))

        if (len(ips_list) > 0):
            md += tableToMarkdown('IPs that hash: ' + file_hash + ' communicates with are:', remove_duplicates_from_list_of_dicts([{'IP':ip} for ip in ips_list]))

        if (len(domains_list) > 0):
            md += tableToMarkdown('Domains that hash: ' + file_hash + ' communicates with are:', remove_duplicates_from_list_of_dicts([{'Domain':domain} for domain in domains_list]))

        if (len(urls_list) > 0):
            md += tableToMarkdown('URLs that hash: ' + file_hash + ' communicates with are:',  remove_duplicates_from_list_of_dicts([{'URL':url} for url in urls_list]))

        return {
            'Type': entryTypes['note'],
            'Contents': network_data,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                  'VirusTotal.hashCommunication.Domain(val==obj)': domains_list,
                  'VirusTotal.hashCommunication.URL(val==obj)': urls_list,
                  'VirusTotal.hashCommunication.IP(val==obj)': ips_list,
                  'VirusTotal.hashCommunication.Host(val==obj)': hosts
            }
        }

    ''' EXECUTION CODE '''
    LOG('command is %s' % (demisto.command(), ))
    try:
        if demisto.command() == 'test-module':
            #This is the call made when pressing the integration test button.
            if get_ip_report('8.8.8.8'):
                demisto.results('ok')
            else:
                demisto.results('test failed')
            pass
        elif demisto.command() == 'vt-check-file-behaviour':
            demisto.results(check_file_behaviour_command())
        elif demisto.command() == 'vt-get-domain-report':
            demisto.results(get_domain_report_command())
        elif demisto.command() == 'vt-get-file-report':
            demisto.results(get_file_report_command())
        elif demisto.command() == 'vt-get-url-report':
            demisto.results(get_url_report_command())
        elif demisto.command() == 'vt-get-ip-report':
            demisto.results(get_ip_report_command())
        elif demisto.command() == 'vt-search-file':
            demisto.results(search_file_command())
        elif demisto.command() == 'vt-ip-to-communicating-hash':
            demisto.results(ip_to_communicating_hash_command())
        elif demisto.command() == 'vt-ip-to-downloaded-hash':
            demisto.results(ip_to_downloaded_hash_command())
        elif demisto.command() == 'vt-ip-to-domain':
            demisto.results(ip_to_domain_command())
        elif demisto.command() == 'vt-domain-to-downloaded-hash':
            demisto.results(domain_to_downloaded_hash_command())
        elif demisto.command() == 'vt-domain-to-communicating-hash':
            demisto.results(domain_to_communicating_hash_command())
        elif demisto.command() == 'vt-hash-communication':
            demisto.results(hash_communication_command())

    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        raise
  type: python
  commands:
  - name: vt-check-file-behaviour
    arguments:
    - name: resource
      required: true
      description: The md5/sha1/sha256 hash of the file whose dynamic behavioural
        report you want to retrieve.
    - name: threshold
      description: If the number of positives is bigger than the threshold the file
        will be considered malicious. If threshold is not specified, the default file
        threshold, as configured in the instance settings, will be used.
    outputs:
    - contextPath: VirusTotal.FileBehaviour.Domain
      description: Domains that the hash communicates with
    - contextPath: VirusTotal.FileBehaviour.URL
      description: URLs that the hash communicates with
    - contextPath: VirusTotal.FileBehaviour.IP
      description: IPs that the hash communicates with
    - contextPath: VirusTotal.FileBehaviour.Host
      description: Hosts that the hash communicates with
    - contextPath: VirusTotal.FileBehaviour.File
      description: Files that are related to this hash
    - contextPath: VirusTotal.FileBehaviour.Key
      description: Keys which are related to this hash
    - contextPath: VirusTotal.FileBehaviour.Mutex
      description: Mutexes which are related to this hash
    description: ' VirusTotal runs a distributed setup of Cuckoo sandbox machines
      that execute the files we receive. This API allows you to retrieve the full
      JSON report of the file''s execution as returned by the Cuckoo JSON report encoder.'
  - name: vt-get-domain-report
    arguments:
    - name: domain
      required: true
      description: A domain name.
    - name: threshold
      description: If the number of positives is bigger than the threshold the domain
        will be considered malicious. If threshold is not specified, the default domain
        threshold, as configured in the instance settings, will be used.
    outputs:
    - contextPath: Domain.Name
      description: Bad domain found
      type: string
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision
      type: string
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the reason for the vendor to make the decision
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: string
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    description: Retrieves a report on a given domain (including the information recorded
      by VirusTotal's passive DNS infrastructure).
  - name: vt-get-file-report
    arguments:
    - name: resource
      required: true
      description: An md5/sha1/sha256 hash of a file for which you want to retrieve
        the most recent antivirus report. You may also specify a scan_id (sha256-timestamp
        as returned by the scan API) to access a specific report.
    - name: allInfo
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: 'VirusTotal metadata, signature information, structural information,
        etc. Can be viewed with raw-response=true. '
    - name: threshold
      description: If the number of positives is bigger than the threshold the file
        will be considered malicious. If threshold is not specified, the default file
        threshold, as configured in the instance settings, will be used.
    - name: longFormat
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Return a full response with scans
    outputs:
    - contextPath: File.MD5
      description: Bad hash found
      type: string
    - contextPath: File.SHA1
      description: Bad hash SHA1
      type: string
    - contextPath: File.SHA256
      description: Bad hash SHA256
      type: string
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
      type: string
    - contextPath: File.Malicious.Detections
      description: For malicious files. Total detections.
      type: number
    - contextPath: File.Malicious.TotalEngines
      description: For malicious files. Total engines
      type: number
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: string
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    description: Retrieves a concluded file scan report for a given file.
  - name: vt-get-url-report
    arguments:
    - name: resource
      required: true
      description: A URL for which you want to retrieve the most recent report. You
        may also specify a scan_id (sha256-timestamp as returned by the URL submission
        API) to access a specific report
    - name: allInfo
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: This additional info includes VirusTotal related metadata (first
        seen date, last seen date, files downloaded from the given URL, etc.) and
        the output of other tools and datasets when fed with the URL.
    - name: longFormat
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Return a full response with scans
    - name: threshold
      description: If the number of positives is bigger than the threshold the file
        will be considered malicious. If threshold is not specified, the default file
        threshold, as configured in the instance settings, will be used.
    outputs:
    - contextPath: URL.Data
      description: Bad URLs found
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision
      type: string
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason for the vendor to make the decision
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: string
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    description: Retrieves a concluded url scan report for a given url.
  - name: vt-get-ip-report
    arguments:
    - name: ip
      required: true
      description: A valid IPv4 address in dotted quad notation, for the time being
        only IPv4 addresses are supported.
    - name: threshold
      description: If the number of positives is bigger than the threshold the file
        will be considered malicious. If threshold is not specified, the default file
        threshold, as configured in the instance settings, will be used.
    outputs:
    - contextPath: IP.Address
      description: Bad IP Address found
      type: string
    - contextPath: IP.ASN
      description: Bad IP ASN
      type: string
    - contextPath: IP.Geo.Country
      description: Bad IP Country
      type: string
    - contextPath: IP.Malicious.Vendor
      description: For malicious IPs, the vendor that made the decision
      type: string
    - contextPath: IP.Malicious.Description
      description: For malicious IPs, the reason for the vendor to make the decision
      type: string
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: string
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    description: Retrieves a report on a given IP address (including the information
      recorded by VirusTotal's Passive DNS infrastructure).
  - name: vt-search-file
    arguments:
    - name: query
      required: true
      description: File search query. For example, query="type:peexe size:90kb+ positives:5+
        behaviour:'taskkill'"
    outputs:
    - contextPath: VirusTotal.FileSearchHashes
      description: The hashes of files that fits the query
      type: unknown
    description: 'This command is equivalent to VirusTotal Intelligence advanced searches.
      A very wide variety of search modifiers are available, including: file size,
      file type, first submission date to VirusTotal, last submission date to VirusTotal,
      number of positives, dynamic behavioural properties, binary content, submission
      file name, and a very long etcetera. The full list of search modifiers allowed
      for file search queries is documented at:  https://www.virustotal.com/intelligence/help/file-search/#search-modifiers'
  - name: vt-ip-to-communicating-hash
    arguments:
    - name: ip
      required: true
      description: IPv4 address
    - name: threshold
      description: If the number of positives is bigger than the threshold the file
        will be considered malicious. If threshold is not specified, the default file
        threshold, as configured in the instance settings, will be used.
    outputs:
    - contextPath: VirusTotal.ipToCommunicatingHash
      description: All the SHA256 hashes related to this ip
    description: Returns all SHA256 hashes of malware that have communicated with
      a given IP address.
  - name: vt-ip-to-downloaded-hash
    arguments:
    - name: ip
      required: true
      description: IPv4 address
    - name: threshold
      description: If the number of positives is bigger than the threshold the file
        will be considered malicious. If threshold is not specified, the default file
        threshold, as configured in the instance settings, will be used.
    outputs:
    - contextPath: VirusTotal.ipToDownloadedHash
      description: SHA256 hashes of malware that have been downloaded from a given
        IP address
    description: Returns all SHA256 hashes of malware that have been downloaded from
      a given IP address.
  - name: vt-ip-to-domain
    arguments:
    - name: ip
      required: true
      description: IPv4 address
    outputs:
    - contextPath: VirusTotal.ipToDomain
      description: Domains that were resolved to this IP
    description: Returns all domains that have resolved to a given IP address based
      on passive DNS history
  - name: vt-domain-to-downloaded-hash
    arguments:
    - name: domain
      required: true
      description: Domain
    - name: threshold
      description: If the number of positives is bigger than the threshold the file
        will be considered malicious. If threshold is not specified, the default file
        threshold, as configured in the instance settings, will be used.
    outputs:
    - contextPath: VirusTotal.domainToDownloadedHash
      description: SHA256 hashes of malware that have been downloaded from a given
        domain
    description: Returns all SHA256 hashes of malware that have been downloaded from
      a given domain.
  - name: vt-domain-to-communicating-hash
    arguments:
    - name: domain
      required: true
      description: Domain
    - name: threshold
      description: If the number of positives is bigger than the threshold the file
        will be considered malicious. If threshold is not specified, the default file
        threshold, as configured in the instance settings, will be used.
    outputs:
    - contextPath: VirusTotal.domainToCommunicatingHash
      description: SHA256 hashes of malware that have communicated with the domain
    description: Returns all SHA256 hashes of malware that have communicated with
      a given domain.
  - name: vt-hash-communication
    arguments:
    - name: hash
      required: true
      description: File Hash
    outputs:
    - contextPath: VirusTotal.hashCommunication.Domain
      description: Domains that the hash communicates with
    - contextPath: VirusTotal.hashCommunication.URL
      description: URLs that the hash communicates with
    - contextPath: VirusTotal.hashCommunication.IP
      description: IPs that the hash communicates with
    - contextPath: VirusTotal.hashCommunication.Host
      description: Hosts that the hash communicates with
    description: Return all Domains, IPs, URLs  that a given SHA256 hash of malware
      communicates with
  runonce: false
releaseNotes: "-"